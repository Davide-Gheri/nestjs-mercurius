import { Injectable, Logger } from '@nestjs/common';
import { GraphQLSchema } from 'graphql';
import {
  GraphQLAstExplorer,
  GraphQLSchemaHost,
  GraphQLFactory as NestGraphQLFactory,
} from '@nestjs/graphql';
import {
  PluginsExplorerService,
  ResolversExplorerService,
  ScalarsExplorerService,
} from '@nestjs/graphql/dist/services';
import { GraphQLSchemaBuilder } from '@nestjs/graphql/dist/graphql-schema.builder';
import { MercuriusModuleOptions } from '../interfaces';
import { ValidationRules } from '../interfaces/base-mercurius-module-options.interface';
import {
  LoadersExplorerService,
  ValidationRuleExplorerService,
} from '../services';
import { transformFederatedSchema } from '../utils/faderation-factory.util';

@Injectable()
export class GraphQLFactory extends NestGraphQLFactory {
  private readonly logger = new Logger(GraphQLFactory.name);

  constructor(
    resolversExplorerService: ResolversExplorerService,
    scalarsExplorerService: ScalarsExplorerService,
    pluginExplorerService: PluginsExplorerService,
    graphqlAstExplorer: GraphQLAstExplorer,
    gqlSchemaBuilder: GraphQLSchemaBuilder,
    gqlSchemaHost: GraphQLSchemaHost,
    protected readonly loaderExplorerService: LoadersExplorerService,
    protected readonly validationRuleExplorerService: ValidationRuleExplorerService,
  ) {
    super(
      resolversExplorerService,
      scalarsExplorerService,
      pluginExplorerService,
      graphqlAstExplorer,
      gqlSchemaBuilder,
      gqlSchemaHost,
    );
  }

  async mergeOptions(options?: any): Promise<any> {
    if (options.federationMetadata) {
      options.buildSchemaOptions = {
        ...options.buildSchemaOptions,
        skipCheck: true,
      };
    }
    const parentOptions = ((await super.mergeOptions(
      options as any,
    )) as unknown) as MercuriusModuleOptions & {
      plugins: unknown;
      schema: GraphQLSchema;
    };
    if ((parentOptions as any).plugins?.length) {
      const pluginNames = (parentOptions as any).plugins
        .map((p) => p.name)
        .filter(Boolean);
      this.logger.warn(
        `Plugins are not supported by Mercurius, ignoring: ${pluginNames.join(
          ', ',
        )}`,
      );
    }
    delete parentOptions.plugins;
    parentOptions.loaders = this.loaderExplorerService.explore();
    parentOptions.validationRules = this.mergeValidationRules(
      options.validationRules,
    );

    if (options.federationMetadata) {
      parentOptions.schema = transformFederatedSchema(parentOptions.schema);
    }

    return parentOptions;
  }

  // async mergeOptions(
  //   options: MercuriusModuleOptions = { typeDefs: [] },
  // ): Promise<MercuriusModuleOptions> {
  //   const resolvers = this.resolversExplorerService.explore();
  //   const typesResolvers = extend(
  //     this.scalarsExplorerService.explore(),
  //     resolvers,
  //   );
  //
  //   const transformSchema = async (schema: GraphQLSchema) =>
  //     options.transformSchema ? await options.transformSchema(schema) : schema;
  //
  //   if (options.autoSchemaFile) {
  //     const autoGeneratedSchema: GraphQLSchema = await this.gqlSchemaBuilder.build(
  //       options.autoSchemaFile,
  //       {
  //         ...options,
  //         buildSchemaOptions: {
  //           ...options.buildSchemaOptions,
  //           skipCheck: options.federationMetadata || false,
  //         }
  //       } as any,
  //       this.resolversExplorerService.getAllCtors(),
  //     );
  //
  //     const executableSchema = makeExecutableSchema({
  //       resolvers: extend(typesResolvers, options.resolvers),
  //       typeDefs: [
  //         gql`
  //           ${printSchema(autoGeneratedSchema)}
  //         `,
  //       ],
  //       resolverValidationOptions: {
  //         ...(options.resolverValidationOptions || {}),
  //         requireResolversForResolveType: false,
  //       },
  //     });
  //     let schema = options.schema
  //       ? mergeSchemas({
  //           schemas: [options.schema as any, executableSchema],
  //         })
  //       : executableSchema;
  //
  //     const autoGeneratedSchemaConfig = autoGeneratedSchema.toConfig();
  //     const schemaConfig = this.overrideOrExtendResolvers(
  //       schema.toConfig(),
  //       autoGeneratedSchemaConfig,
  //     );
  //
  //     schema = new GraphQLSchema(schemaConfig);
  //     if (options.schemaDirectives) {
  //       SchemaDirectiveVisitor.visitSchemaDirectives(
  //         schema,
  //         options.schemaDirectives,
  //       );
  //     }
  //
  //     schema = await transformSchema(schema);
  //     schema = await transformFederatedSchema(schema);
  //
  //     schema = options.sortSchema ? lexicographicSortSchema(schema) : schema;
  //
  //     this.gqlSchemaHost.schema = schema;
  //
  //     return {
  //       ...options,
  //       typeDefs: undefined,
  //       validationRules: this.mergeValidationRules(options.validationRules),
  //       loaders: this.loaderExplorerService.explore(),
  //       schema,
  //     };
  //   }
  //   if (isEmpty(options.typeDefs)) {
  //     const schema = await transformSchema(options.schema as any);
  //     this.gqlSchemaHost.schema = schema;
  //     return {
  //       ...options,
  //       typeDefs: undefined,
  //       schema,
  //     };
  //   }
  //   const executableSchema = makeExecutableSchema({
  //     resolvers: extend(typesResolvers, options.resolvers),
  //     directiveResolvers: options.directiveResolvers,
  //     schemaDirectives: options.schemaDirectives as any,
  //     typeDefs: gql`
  //       ${options.typeDefs}
  //     `,
  //     resolverValidationOptions: options.resolverValidationOptions,
  //   });
  //   let schema = options.schema
  //     ? mergeSchemas({
  //         schemas: [options.schema as any, executableSchema],
  //       })
  //     : executableSchema;
  //
  //   removeTempField(schema);
  //   schema = await transformSchema(schema);
  //   schema = options.sortSchema ? lexicographicSortSchema(schema) : schema;
  //   this.gqlSchemaHost.schema = schema;
  //
  //   return {
  //     ...options,
  //     typeDefs: undefined,
  //     schema,
  //   };
  // }

  mergeValidationRules(existingValidationRules?: ValidationRules) {
    const rules = this.validationRuleExplorerService.explore();
    return (params) => [
      ...(existingValidationRules ? existingValidationRules(params) : []),
      ...rules.map((rule) => (context) => rule.validate(params, context)),
    ];
  }
}
